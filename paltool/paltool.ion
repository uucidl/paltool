var USAGE = "<paltool> <root-directory>";

import filesystem { ... }
import libc { ... }
import tasks { ... }
import codecs { ... }

struct Image
{
  num_pixels : usize;
  pixels : RGB24*;
  task : Task;
  task_data : CountHueTask*;
}

func is_ptr_aligned(ptr : void*, alignment : int) : bool
{
  return uintptr(ptr) & (alignment - 1) == 0;
}

func image_from_file(image : Image*, abspath : char*)
{
  x : int;
  y : int;
  n : int;
  data := image_load(abspath, &x, &y, &n, 3);

  #assert(is_ptr_aligned(data, alignof(RGB24)));
  image.pixels = (:RGB24*)data;
  image.num_pixels = x*y;
  image.task_data = calloc(1, sizeof(*image.task_data));
  image.task_data.ipt96_from_rgb24 = allocate_ipt96_from_rgb24(
    image.num_pixels, image.pixels);
  image.task_data.count_hue = CountHueTransform{
    num_pixels = image.num_pixels,
    inputIPT96 = image.task_data.ipt96_from_rgb24.outputIPT96,
  };
  image.task = create_task(count_hue_task, image.task_data);
  start_task(image.task);
}

func main(argc: int, argv: char**) : int {
  test_colorspaces();
  test_ipt96_from_rgb24_transform();
  test_pack_pt();

  tasks_init();
  path : char*;
  argi := 1;
  expect_str(&argi, argc, argv, &path);
  printf("INFO: listing all files from root: %s\n", path);
  paths := find_all_files_recursively((:uint8*)path);

  source_images : Image*;
  source_images = buf_fit(source_images, sizeof(source_images[0]), 0);
  while (paths.error == PathListError_None) {
    for (i := 0; i < paths.output.num_dirpaths; i++) {
      printf("[d]\t%s\n", paths.output.dirpaths[i]);
    }
    for (i := 0; i < paths.output.num_filepaths; i++) {
      file := paths.output.filepaths[i];
      printf("[f]\t%s", file);
      if (str_match_suffix((:char*)file, ".jpg") || str_match_suffix((:char*)file, ".JPG")) {
	abspath : char*;
	strbuf_catf(&abspath, "%s/%s", path, (:char*)file);
	image : Image;
	image_from_file(&image, abspath);
	if (!image.pixels) {
	  printf("\t[corrupt]");
	} else {
	  printf("\t[image/jpeg]");
	}
	source_images = buf_fit(source_images, sizeof(source_images[0]), 1);
	buf_push(source_images, &image, sizeof(image), 1);
	buf_free(abspath);
      }
      printf("\n");
    }
    next_paths(&paths);
  }
  if (paths.error != PathListError_PastTheEnd) {
    printf("ERROR: %d\n", paths.error);
  }
  free_generator(&paths);
  // busy loop for remaining tasks
  num_remaining_tasks := 0;
  do {
    num_remaining_tasks = 0;
    for (i:=0; i<buf_len(source_images, sizeof(source_images[0])); i++) {
      num_remaining_tasks += !source_images[i].task_data.done? 1 : 0;
    }
  } while (num_remaining_tasks > 0);

  // @todo: merge results, count occurrences per area
  hue_counts_per_task :  HueCounts* = buf_fit(NULL, sizeof(HueCounts), buf_len(source_images, sizeof(source_images[0])));
  for (i:=0; i<buf_len(source_images, sizeof(source_images[0])); i++) {
    buf_push(hue_counts_per_task, &source_images[i].task_data.count_hue.result, sizeof(source_images[i].task_data.count_hue.result), 1);
  }
  hue_counts := merge_hue_counts(buf_len(hue_counts_per_task, sizeof(hue_counts_per_task[0])), &hue_counts_per_task[0]);
  // Report:
  printf("num_hues: %zu\n", buf_len(hue_counts.hues, sizeof(hue_counts.hues[0])));
  for(hue_i:=0; hue_i<buf_len(hue_counts.hues, sizeof(hue_counts.hues[0])); hue_i++) {
    hue := hue_counts.hues[hue_i];
    if (hue.num == 1) { continue; }
    srgb : float[3];
    xyz : float[3];
    xyz_from_ipt(1, xyz, 3, hue.ipt, 3);
    srgb_from_xyz(1, srgb, 3, xyz, 3);
    printf("%zu\t%f\t#%02x %02x %02x\n", hue.num, hue.hue_angle, int(0xff*srgb[0]), int(0xff*srgb[1]), int(0xff*srgb[2]));
  }
  tasks_deinit();
  return 0;
}

// @todo separate transform into:
//
// IPTFromRGBTransform > CountHueTransform
//
// In particular, having IPT separately can allow us more flexible hue groupings.
//
// IPTFromRGBTransform > SortBy{PT,I} > CountPT+CountIByPT

struct RGB24
{
  r, g, b: uint8;
}

struct IPT96
{
  i, p, t : float;
}

func ipt96_isequal(a : IPT96, b: IPT96) : bool
{
  return a.i == b.i && a.p == b.p && a.t == b.t;
}
  
struct IPT96FromRGB24Transform
{
  num_pixels : usize;
  inputRGB24 : RGB24*;
  outputIPT96 : IPT96*;
}

func allocate_ipt96_from_rgb24(num_pixels : usize, input : RGB24*) : IPT96FromRGB24Transform
{
  output := calloc(num_pixels, sizeof(IPT96));
  return { num_pixels = num_pixels, inputRGB24 = input, outputIPT96 = output };
}

func free_ipt96_from_rgb24(transform : IPT96FromRGB24Transform*)
{
  free(transform.outputIPT96);
  transform.outputIPT96 = NULL;
}

struct CountHueTransform
{
  num_pixels : usize;
  inputIPT96 : IPT96*;
  result : HueCounts;
}

struct HueWithOccurence
{
  hue_angle : float;
  num : usize;
  ipt : float[3];
}

struct HueCounts
{
  num_pixels : usize;
  hues : HueWithOccurence*;
  hue_occurences : Map; // @todo: can be moved away after use, actually transient
}

func bits_float(x : float) : uint32
{
  y : uint32;
  #static_assert(sizeof(float) == sizeof(uint32));
  memcpy(&y, &x, sizeof(y));
  return y;
}

func count_hue_hue_key(hue_angle : float) : uint64
{
  return 0xf | (bits_float(hue_angle)<<4);
}

func record_raw_hue(count : HueCounts*, hue_elem : HueWithOccurence)
{
  hue_key := count_hue_hue_key(hue_elem.hue_angle);
  hue_idx_plus_one := intptr(map_get(&count.hue_occurences, hue_key));
  if (hue_idx_plus_one == 0)
  {
    hue_idx_plus_one = buf_len(count.hues, sizeof(count.hues[0])) + 1;
    count.hues = buf_fit(count.hues, sizeof(count.hues[0]), 1);
    buf_push(count.hues, &hue_elem, sizeof(hue_elem), 1);
    map_put(&count.hue_occurences, hue_key, (:void*)hue_idx_plus_one);
  }
  else
  {
    d_hue := &count.hues[hue_idx_plus_one - 1];
    d_hue.num += hue_elem.num;
    if (hue_elem.ipt[0] > d_hue.ipt[0]) {
      d_hue.ipt[0] = hue_elem.ipt[0];
      d_hue.ipt[1] = hue_elem.ipt[1];
      d_hue.ipt[2] = hue_elem.ipt[2];
    }
  }
}


struct FooTransform
{
  num_pixels : usize;
  inputIPT96 : IPT96*;
  num_bits : int;
  packed_hues_buf : uint32*;
}

func pack_su_float(f : float, num_bits : int) : uint32
{
  one_as_int := 1<<(num_bits-1);
  positive_max := one_as_int - 1;
  one := float(positive_max);
  return uint32(int32(f*one) << (32-num_bits)) >> (32-num_bits);
}

func unpack_su_float(packed : uint32, num_bits : int) : float
{
  one_as_int := 1<<(num_bits - 1);
  positive_max := one_as_int - 1;
  one := float(positive_max);
  as_int : int32 = sign_extend(bits(packed, 0, num_bits), num_bits);
  return as_int/one;
}

func pack_pt(ipt : IPT96, num_bits : int) : uint32
{
  return (pack_su_float(ipt.p, num_bits)<<num_bits) | pack_su_float(ipt.t, num_bits);
}

func unpack_pt(packed : uint32, num_bits : int) : IPT96
{
  one_as_int := 1<<(num_bits - 1);
  positive_max := one_as_int - 1;
  one := float(positive_max);
  p_as_int : int32 = sign_extend(bits(packed, num_bits, num_bits), num_bits);
  t_as_int : int32 = sign_extend(bits(packed, 0, num_bits), num_bits);
  return { p=p_as_int/one, t=t_as_int/one };
}

func test_pack_pt()
{
  bit_sizes : int[] = { 8, 9, 10 };
  num_bit_sizes := sizeof(bit_sizes)/sizeof(bit_sizes[0]); // @todo I wish I had countof
  for (i:=0; i<num_bit_sizes; i++) {
    num_bits := bit_sizes[i];
    y := pack_pt({t=1.0}, num_bits);
    pt := unpack_pt(y, num_bits);
#assert(ipt96_isequal(pt, {t = 1.0}));
    
    y = pack_pt({t=-1.0}, num_bits);
    pt = unpack_pt(y, num_bits);
#assert(ipt96_isequal(pt, {t = -1.0}));
    
    y = pack_pt({p=1.0}, num_bits);
    pt = unpack_pt(y, num_bits);
#assert(ipt96_isequal(pt, {p=1.0}));
    
    y = pack_pt({p=-1.0}, num_bits);
    pt = unpack_pt(y, num_bits);
#assert(ipt96_isequal(pt, {p=-1.0}));
  }
}
  
func run_foo(foo : FooTransform*)
{
  #assert(foo.num_bits > 0 && 2*foo.num_bits <= 30);
  foo.packed_hues_buf = buf_fit(foo.packed_hues_buf, sizeof(foo.packed_hues_buf[0]), foo.num_pixels);
  for (i:=0; i<foo.num_pixels; i++) {
    foo.packed_hues_buf[i] = pack_pt(foo.inputIPT96[i], foo.num_bits);
  }
}


// @todo window colors to not over represent highs and lows

struct CountHueTask
{
  done : bool;
  ipt96_from_rgb24 : IPT96FromRGB24Transform;
  count_hue : CountHueTransform;
  foo : FooTransform;
}

func count_hue_task(opaque_data : void*)
{
  task : CountHueTask* = opaque_data;
  run_ipt96_from_rgb24(&task.ipt96_from_rgb24);
  run_count_hues(&task.count_hue);

  task.foo.num_pixels = task.ipt96_from_rgb24.num_pixels;
  task.foo.inputIPT96 = task.ipt96_from_rgb24.outputIPT96;
  task.foo.num_bits = 8;
  run_foo(&task.foo);
  
  // @todo should deallocation be inside the task?
  free_ipt96_from_rgb24(&task.ipt96_from_rgb24);

  image_free((:uint8*)task.ipt96_from_rgb24.inputRGB24); // @todo move outside to dependent task
  task.ipt96_from_rgb24.inputRGB24 = NULL;
  task.done = true;
}

func merge_hue_counts(num_counts : usize, counts : HueCounts*) : HueCounts
{
  // @todo normalize probability per surface area.
  result : HueCounts;
  for (count_i:=0; count_i<num_counts; count_i++) {
      count := counts[count_i];
      for (hue_i:=0; hue_i<buf_len(count.hues, sizeof(counts.hues[0])); hue_i++) {
	  hue := count.hues[hue_i];
	  record_raw_hue(&result, hue);
	  result.num_pixels += count.num_pixels;
      }
  }
  return result;
}

func clamp_float(x : float, min : float, max : float) : float
{
  return x < min? min : (x > max? max : x);
}


func run_ipt96_from_rgb24(transform : IPT96FromRGB24Transform*)
{
  num_pixels := transform.num_pixels;
  buffer1 : float* = calloc(num_pixels*3, sizeof(float));
  buffer2 : float* = calloc(num_pixels*3, sizeof(float));
  for (i:=0; i<num_pixels; i++) {
    buffer1[3*i+0] = float(transform.inputRGB24[i].r)/255.0;
    buffer1[3*i+1] = float(transform.inputRGB24[i].g)/255.0;
    buffer1[3*i+2] = float(transform.inputRGB24[i].b)/255.0;
  }
  xyz_from_srgb(transform.num_pixels, buffer2, 3, buffer1 , 3);
  ipt_from_xyz(transform.num_pixels, buffer1, 3, buffer2, 3);
  for (i:=0; i<num_pixels; i++) {
    transform.outputIPT96[i].i = buffer1[3*i+0];
    transform.outputIPT96[i].p = buffer1[3*i+1];
    transform.outputIPT96[i].t = buffer1[3*i+2];
  }
  free(buffer1);
  free(buffer2);
}

func run_count_hues(transform : CountHueTransform*)
{
  transform.result.hues = buf_fit(
    transform.result.hues,
    sizeof(transform.result.hues[0]),
    transform.num_pixels/4);

  src := transform.inputIPT96;
  for (i:=0; i<transform.num_pixels; i++) {
    ipt : float[3] = { src[i].i, src[i].p, src[i].t };
    hue_angle := atan2(ipt[1], ipt[2]);
    // @todo pass as parameter
    quantized_hue_angle := round(3000.0*hue_angle)/3000.0;
    record_raw_hue(&transform.result, {
	hue_angle = quantized_hue_angle,
	num = 1,
	ipt = { ipt[0], ipt[1], ipt[2] },
    });
  }
}

func test_ipt96_from_rgb24_transform()
{
  rgb : RGB24[3] = {
    { r=0xff },
    { g=0xff },
    { b=0xff },
  };
  ipt : IPT96[3];
  transform := IPT96FromRGB24Transform{
    num_pixels = 3,
    inputRGB24 = rgb,
    outputIPT96 = ipt,
  };
  run_ipt96_from_rgb24(&transform);
  for (i:=0; i<3; i++) {
    fipt : float[3] = {
      ipt[i].i,
      ipt[i].p,
      ipt[i].t,
    };
    rrgb : float[3];
    txyz : float[3];
    xyz_from_ipt(1, txyz, 3, fipt, 3);
    srgb_from_xyz(1, rrgb, 3, txyz, 3);
    frgb : float[3] = {
      rgb[i].r/255.0,
      rgb[i].g/255.0,
      rgb[i].b/255.0,
    };
    #assert(almost_equal_3x(frgb, rrgb, 2.0/255.0));
  }
}
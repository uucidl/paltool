var USAGE = "<paltool> <root-directory>";

import filesystem { ... }
import libc { ... }
import tasks { ... }
import codecs { ... }

func strbuf_push(bufptr : char**, str : char const*) {
  n := strlen(str);
  *bufptr = buf_fit(*bufptr, sizeof(**bufptr), n);
  buf_push(*bufptr, str, n);
}

func strbuf_terminate(bufptr : char**) {
  *bufptr = buf_fit(*bufptr, sizeof(**bufptr), 1);
  buf_push(*bufptr, "\0", 1);
}

func main(argc: int, argv: char**) : int {
  test_colorspaces();

  tasks_init();
  path : char*;
  argi := 1;
  expect_str(&argi, argc, argv, &path);
  printf("INFO: listing all files from root: %s\n", path);
  paths := find_all_files_recursively((:uint8*)path);
  tasks : Task*;
  hue_transforms : HueTransform**;
  while (paths.error == PathListError_None) {
    for (i := 0; i < paths.output.num_dirpaths; i++) {
      printf("[d]\t%s\n", paths.output.dirpaths[i]);
    }
    for (i := 0; i < paths.output.num_filepaths; i++) {
      file := paths.output.filepaths[i];
      printf("[f]\t%s", file);
      if (str_match_suffix((:char*)file, ".jpg") || str_match_suffix((:char*)file, ".JPG")) {
        abspath : char*;
        strbuf_push(&abspath, path);
        strbuf_push(&abspath, "/");
        strbuf_push(&abspath, (:char*)file);
        strbuf_push(&abspath, "\0");
        strbuf_terminate(&abspath);
	printf("\t[image/jpeg]");
        x : int;
        y : int;
        n : int;
        data := image_load(abspath, &x, &y, &n, 3);
	buf_free(abspath);
	abspath = NULL;
	
        transform : HueTransform* = calloc(1, sizeof(HueTransform));
	transform.pixelsRGB24 = data;
	transform.num_pixels = x*y;
        task := create_task(hue_transform_task, transform);
	tasks = buf_fit(tasks, sizeof(tasks[0]), 1);
	buf_push(tasks, &task, sizeof(tasks[0]));
	hue_transforms = buf_fit(hue_transforms, sizeof(hue_transforms[0]), 1);
	buf_push(hue_transforms, &transform, sizeof(transform));
      }
      printf("\n");
    }
    next_paths(&paths);
  }
  if (paths.error != PathListError_PastTheEnd) {
    printf("ERROR: %d\n", paths.error);
  }
  for (i:=0; i<buf_len(tasks, sizeof(tasks[0])); i++) {
    start_task(tasks[i]);
  }
  free_generator(&paths);
  // busy loop for remaining tasks
  num_remaining_tasks := 0;
  do {
    num_remaining_tasks = 0;
    for (i:=0; i<buf_len(hue_transforms, sizeof(hue_transforms[0])); i++) {
      num_remaining_tasks += hue_transforms[i].pixelsRGB24? 1 : 0;
    }
  } while (num_remaining_tasks > 0);
  tasks_deinit();
  return 0;
}

func str_match_suffix(str : char const*, suffix : char const*) : bool {
  n := strlen(str);
  mn := strlen(suffix);
  while(n && mn && str[n - 1] == suffix[mn - 1]) {
    mn--;
    n--;
  }
  return mn == 0; 
}

func expect_arg(argi: int, argc: int, argv: char**, error : char*) {
  if (argi >= argc) {
    die_at(argi, argc, argv, error);
  }
}

func expect_str(argi: int*, argc: int, argv: char**, dest_str : char**) {
  expect_arg(*argi, argc, argv, "expected string");
  *dest_str = argv[*argi];
  *argi = *argi + 1;
}

func die_at(argi: int, argc:int, argv: char**, error: char*) {
  printf("ERROR: %s:\n", error);
  {
    printf("ERROR: ");
    pre := "";
    for (i:=0; i<argc; i++) {
      printf("%s%s", pre, argv[i]);
      pre = " ";
    }
    printf("\n");
  }
  printf("ERROR: ");
 pre := "";
 for (i:=0; i<argi; i++) {
   printf("%s%*s", pre, (:int)strlen(argv[i]), "");
   pre = " ";
 }
 if (argi < argc)
 {
   printf("%s", pre);
   for (i:=0; i<strlen(argv[argi]); i++) {
     printf("^");
   }
   pre = " ";
 }
 else
 {
   printf("%s%s", pre, "^");
 }
 pre = " ";
 for (i:=argi+1; i<argc; i++) {
   printf("%s%*s", pre, (:int)strlen(argv[i]), "");
   pre = " ";
 }
 printf("\n");
 printf("USAGE: %s\n", USAGE);
 exit(1);
}

struct HueTransform
{
  num_pixels : usize;
  pixelsRGB24 : uint8*;
  hues_occurences : Map;
}

func bits_float(x : float) : uint32
{
  y : uint32;
  #static_assert(sizeof(float) == sizeof(uint32));
  memcpy(&y, &x, sizeof(y));
  return y;
}
  
func hue_transform_hue_key(hue_angle : float) : uint64
{
  return 0xf | (bits_float(hue_angle)<<4);
}
  
func hue_transform_task(opaque_data : void*)
{
  transform : HueTransform* = opaque_data;
  {
    src := transform.pixelsRGB24;
    for (i:=0; i<transform.num_pixels; i++) {
      srgb : float[3] = { src[0]/255.0, src[1]/255.0, src[2]/255.0 };
      xyz : float[3];
      xyz_from_srgb(1, xyz, 3, srgb, 3);
      ipt : float[3];
      ipt_from_xyz(1, ipt, 3, xyz, 3);
      hue_angle := atan2(ipt[1], ipt[2]);
      printf("%f\n", hue_angle);
      src += 3;
    }
  }
  image_free(transform.pixelsRGB24); // @todo move outside to dependent task
  transform.pixelsRGB24 = NULL;
}

struct Map
{
  keys : uint64*;
  ptrs : void*;
  cap : usize;
  len : usize;
}

func map_grow(map : Map, size : usize)
{
  #assert(false);
}

func map_free(map : Map*)
{
  #assert(false);
}

// returns value at key
func map_get(map : Map const*, key : uint64) : void*
{
  #assert(false);
  return NULL;
}

// grows the map if necessary
func map_put(map : Map*, key : uint64, data : void*)
{
  #assert(false);
}

func map_remove(map : Map*, key : uint64)
{
  #assert(false);
}

func hash_uint64(x : uint64) : uint64
{
  x *= 0xff51afd7ed558ccd;
  x ^= x >> 32;
  return x;
}

func hash_bytes(bytes : char const*, num_bytes : usize) : uint64
{
  x : uint64 = 0xcbf29ce484222325;
  for (i:=0; i<num_bytes; i++)
  {
    x ^= bytes[i];
    x *= 0x100000001b3;
    x ^= x >> 32;
  }
  return x;
}

func hash_ptr(ptr : void const*) : uint64
{
  return hash_uint64(uintptr(ptr));
}  


import containers {...}
import win32 {...}
import libc {
  libc_calloc = calloc,
  libc_free = free
}

struct PlatformPathListGenerator
{
  query : HANDLE;
  arena : MemoryArena;
}

func platform_find_all_files_recursively(root : uint8 const*) : PathListGenerator
{
     
    necessary_wchars := MultiByteToWideChar(CP_UTF8, 0, (:char const*)root, -1, NULL, 0);
	root_u : wchar* = buf_fit(NULL, sizeof(int16), necessary_wchars + 1);
    // @todo prefix with \\?\
	wrote := MultiByteToWideChar(CP_UTF8, 0, (:char const*)root, -1, &root_u[buf_len(root_u)], buf_cap(root_u)-buf_len(root_u));
    if (wrote > 0)
    {
      buf_hdr(root_u).size = wrote * sizeof(root_u[0]);
      #assert(buf_len(root_u) == necessary_wchars);
    }

	// @todo: disallow ending \\ or / or always append \* to the path

	result := PathListGenerator{
      error = PathListError_InvalidRoot
    };

    // Open query and get info about first file:
    one_file : WIN32_FIND_DATAW;
    AdditionalFlags := FIND_FIRST_EX_LARGE_FETCH; // @todo @platform_specific{windows>7}
	query := FindFirstFileExW(root_u, FindExInfoStandard, &one_file, FindExSearchNameMatch, NULL, AdditionalFlags);

    if (query != INVALID_HANDLE_VALUE) {
		result.resources = libc_calloc(1, sizeof(PlatformPathListGenerator));
        *result.resources = {
          query = query,
        };
		fill_path_list_from_win32_find_data(&result.output, root_u, one_file, &result.resources.arena);
        result.error = PathListError_None;
    }
    buf_free(root_u);
    // @todo preserve root in list result
	return result;
}

func fill_path_list_from_win32_find_data(list : PathList*, root : wchar*, file : WIN32_FIND_DATAW, arena : MemoryArena*)
{
    *list = {};
	if (file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
		list.num_dirpaths = 1;
        list.dirpaths = arena_alloc(arena, sizeof(:uint8*));
        list.dirpaths[0] = zutf8_from_zwchar_arena(file.cFileName, arena);
    } else {
        list.num_filepaths = 1;
        list.filepaths = arena_alloc(arena, sizeof(:uint8*));
        list.filepaths[0] = zutf8_from_zwchar_arena(file.cFileName, arena);
    }
}

func platform_next_paths(generator : PathListGenerator*)
{
  one_file : WIN32_FIND_DATAW;
  if (!FindNextFileW(generator.resources.query, &one_file)) {
      generator.error = PathListError_PastTheEnd;
      return;
  }
  arena_reset(&generator.resources.arena);
  fill_path_list_from_win32_find_data(&generator.output, NULL, one_file, &generator.resources.arena);
}

func platform_free_generator(generator : PathListGenerator*)
{
  if (!generator.resources) { return; }
  arena_free(&generator.resources.arena);
  libc_free(generator.resources);
  generator.resources = NULL;
}


func zutf8_from_zwchar_arena(zwstring : wchar*, arena : MemoryArena*) : uint8*
{	
	necessary_bytes := WideCharToMultiByte(CP_UTF8, 0, zwstring, -1, NULL, 0, NULL, NULL);
	output : char* = arena_alloc(arena, necessary_bytes);
    WideCharToMultiByte(CP_UTF8, 0, zwstring, -1, output, necessary_bytes, NULL, NULL);
    return (:uint8*)output;
}


struct MemorySegment
{
  size : usize;
  used : usize;
  bytes : uint8[1];
}

struct MemoryArena
{
  segments_buf : MemorySegment**;
}

func arena_alloc(arena : MemoryArena*, size : usize) : void*
{
    available_size := buf_len(arena.segments_buf) == 0? 0 : arena_segment_available_size(arena.segments_buf[buf_len(arena.segments_buf)-1]);
	segment : MemorySegment*;
    if (size > available_size) {
      segment_size := usize(2*1024*1024);
      segment_size = size>segment_size? size:segment_size;
	  segment = libc_calloc(1, sizeof(MemorySegment) + segment_size - 1);
      *segment = {
		size = segment_size
      };
	  buf_push(&arena.segments_buf, &segment, sizeof(segment));
    } else {
      segment = arena.segments_buf[buf_len(arena.segments_buf) - 1];
    }
    ptr := &segment.bytes[segment.used];
    segment.used += size;
    #assert(segment.used <= segment.size);
    return ptr;
}

func arena_reset(arena : MemoryArena*)
{
	for (i:=0; i<buf_len(arena.segments_buf); i++) {
		arena_segment_reset(arena.segments_buf[i]);
    }
}

func arena_free(arena : MemoryArena*)
{
	for (i:=0; i<buf_len(arena.segments_buf); i++) {
		libc_free(arena.segments_buf[i]);
    }
    buf_free(arena.segments_buf);
    arena.segments_buf = NULL;
}

func arena_segment_reset(segment : MemorySegment*)
{
   segment.used = 0;
}

func arena_segment_available_size(segment : MemorySegment const*) : usize
{
	return segment.size - segment.used;
}


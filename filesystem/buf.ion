struct BufHeader
{
  capacity : int32;
  size     : int32;
  magic    : int64;
  bytes    : uint8[1];
}

const BufHeaderMagic = 0x6731;

func buf_hdr(bufptr : void*) : BufHeader*
{
  addr := ((:uint8*) bufptr) - offsetof(BufHeader, bytes);
  hdr := (:BufHeader*) addr;
  #assert(hdr.magic & 0xffff == BufHeaderMagic);
  #assert(hdr.capacity >= 0);
  #assert(hdr.size >= 0);
  return hdr;  
}

func buf_free(bufptr : void*)
{
  if (!bufptr) {
    return;
  }

  hdr := buf_hdr(bufptr);
  hdr.magic = 0x0000;
  free(hdr);
}

func buf_check_elem_size(hdr : BufHeader*, elem_size : usize)
{
  #assert(elem_size < uint64(1)<<48);
  hdr_elem_size := buf_bits(hdr.magic, 16, 48);
  if(hdr_elem_size == 0) {
    hdr_elem_size = elem_size;
    hdr.magic |= hdr_elem_size<<16;
  }
  #assert(hdr_elem_size == elem_size);
}

func buf_fit(bufptr : void*, elem_size : usize, num_added : usize) : void*
{
  added_size := num_added*elem_size; // @todo overflow check
  hdr := bufptr? buf_hdr(bufptr) : NULL;
  if (!hdr)
  {  
	hdr = calloc(1, sizeof(BufHeader) + added_size);
	*hdr = {
	     capacity = added_size,
	     magic = BufHeaderMagic,
	};
        buf_check_elem_size(hdr, elem_size);
	return &hdr.bytes[0];
  }
  buf_check_elem_size(hdr, elem_size);
  size := added_size + hdr.size;
  #assert(size < INT32_MAX);
  #assert((hdr.magic & 0xffff) == BufHeaderMagic);
  need_capacity := size;
  if (need_capacity > hdr.capacity)
  {
    old_capacity := hdr.capacity;
    next_capacity := 2*old_capacity;
    new_capacity := need_capacity>next_capacity? need_capacity:next_capacity;
    hdr = realloc(hdr, sizeof(BufHeader) + new_capacity);
    memset(&hdr.bytes[old_capacity], 0, new_capacity - old_capacity);
    hdr.capacity = new_capacity;
    #assert(hdr.capacity >= size);
  }
  return &hdr.bytes[0];
}

func buf_push(bufptr : void*, data : void const*, elem_size : usize, num_added : usize)
{
  hdr := buf_hdr(bufptr);
  #assert(buf_bits(hdr.magic, 0, 16) == BufHeaderMagic);
  buf_check_elem_size(hdr, elem_size);
  // @todo overflow check
  data_size := elem_size * num_added;
  #assert(data_size < INT32_MAX - hdr.capacity);
  #assert(data_size <= hdr.capacity - hdr.size);
  memcpy(&hdr.bytes[hdr.size], data, data_size);
  hdr.size += data_size;
}

func buf_cap(bufptr : void*) : usize
{
  cap := bufptr? buf_hdr(bufptr).capacity : 0;
  return cap;
}

func buf_len(bufptr : void*, elem_size : usize) : usize
{
  size := bufptr? buf_hdr(bufptr).size : 0;
  #assert(size % elem_size == 0);
  return size/elem_size;
}

func buf_bits(x : uint64, start : int, len : int) : uint64 {
  return (x>>start) & ((uint64(1)<<len) - 1);
}

func buf_push(opaque_buf_ptr : void*, elem : void*, elem_size : usize)
{
  buf_ptr := (:void**)opaque_buf_ptr;
  *buf_ptr = buf_fit(*buf_ptr, elem_size, 1);
  buf__add_n(*buf_ptr, elem, elem_size, 1);
}

func buf_cap(opaque_buf : void*) : usize
{
  return array_capacity(buf_hdr(opaque_buf));
}

func buf_len(opaque_buf : void*) : usize
{
  return array_length(buf_hdr(opaque_buf));
}

func buf_free(opaque_buf : void*)
{
  array_reset(buf_hdr(opaque_buf));
}

func buf_fit(opaque_buf : void*, elem_size : usize, num_added : usize) : void*
{
  hdr := buf_hdr(opaque_buf);
  old_size := array_size(hdr);
  hdr = array_alloc(hdr, num_added + array_length(hdr), elem_size);
  hdr.size = old_size;
  return &hdr.bytes[0];
}

func buf__add_n(opaque_buf : void*, data : void const*, elem_size : usize, num_added : usize)
{
  hdr := buf_hdr(opaque_buf);
  // @todo overflow check
  data_size := num_added * elem_size;
  available_size := hdr.capacity - hdr.size;
  #assert(data_size <= available_size);
  memcpy(&hdr.bytes[hdr.size], data, data_size);
  hdr.size += elem_size;
}

func buf_hdr(opaque_buf : void*) : Array*
{
  if (!opaque_buf) { return NULL; }
  addr := ((:uint8*) opaque_buf) - offsetof(Array, bytes);
  hdr := (:Array*) addr;
  array__check_magic(hdr);
  return hdr;
}
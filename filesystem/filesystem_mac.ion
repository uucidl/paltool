import .bsd { ... }
import libc { printf }

struct PlatformPathListGenerator
{
  dummy : int;
}

struct QueryResult
{
  size       : uint32;       // [0..4)
  attributes : AttributeSet; // [4..24)
  error : uint32;            // [24..28)
  nameinfo : Attrreference;  // [28..36)
  objtype : FSObjType;       // [36..40)
  objtag : FSObjTag;         // [40..44)
  union {
    struct {
      file_totalsize : Off;      // [44..52)
      file_ioblocksize : uint32; // [52..56)
    }
  }
  name       : char*;        // derived
}

func unpack_query_result(bytes : uint8 const*, num_bytes : usize) : QueryResult {
  nameinfo := *((:Attrreference*)&bytes[28]);
  return {
    size = *((:uint32*)&bytes[0]),
    attributes = *((:AttributeSet*)&bytes[4]),
    error = *((:uint32*)&bytes[24]),
    nameinfo = *((:Attrreference*)&bytes[28]),
    objtype = *((:FSObjType*)&bytes[36]),
    objtag = *((:FSObjType*)&bytes[40]),
    file_totalsize = *((:Off*)&bytes[44]),
    file_ioblocksize = *((:uint32*)&bytes[52]),
    name = (:char*)&bytes[28 + nameinfo.attr_dataoffset],
  };
}
  
func make_attrlist_for_QueryResult() : AttrList
{
  return make_attrlist({
      commonattr = ATTR_CMN_RETURNED_ATTRS | ATTR_CMN_ERROR | ATTR_CMN_NAME | ATTR_CMN_OBJTYPE | ATTR_CMN_OBJTAG,
      fileattr = ATTR_FILE_TOTALSIZE | ATTR_FILE_IOBLOCKSIZE,
  });
}

func platform_find_all_files_recursively(root : uint8 const*) : PathListGenerator
{
  root_path := (:char const*)root;
  fd_or_error := open(root_path, O_RDONLY, 0);
  if (fd_or_error < 0) {
    return { error = PathListError_InvalidRoot };
  }
  #assert(fd_or_error >= 0);
  root_fd := fd_or_error;
  query := make_attrlist_for_QueryResult();
  options := uint64(FSOPT_NOFOLLOW | FSOPT_REPORT_FULLSIZE | FSOPT_PACK_INVAL_ATTRS);
  batch_mem : uint32[16*256];
  num_entries_or_error := getattrlistbulk(root_fd, &query, &batch_mem[0], sizeof(batch_mem), options);
  if (num_entries_or_error < 0)
  {
    #assert(errno != EFAULT);
    #assert(errno != ERANGE);
    #assert(errno != EINVAL);
    close(root_fd);
    return {
      error = (errno == EBADF || errno == ENOTDIR)
	? PathListError_InvalidRoot
        : PathListError_FileSystemError
    };
  }
  
  // TODO(nil): bug, bad layout for QueryResult results in weird sizes..
  #assert(num_entries_or_error >= 0);
  num_entries := num_entries_or_error;
  batch_offset := 0;
  next_entry := (:uint8*)&batch_mem[0];
  printf("entries = {\n");  
  for (entries_idx := 0; entries_idx < num_entries; entries_idx++) {
    remaining_num_bytes := (:uint8*)&batch_mem[sizeof(batch_mem)] - next_entry;
    entry := unpack_query_result(next_entry, remaining_num_bytes);
    printf("  [%d] = {\n", entries_idx);
    printf("    type = %d,\n", entry.objtype);
    printf("    name = %s,\n", entry.name);
    printf("    error = %d,\n", entry.error);
    if (entry.objtype == VREG) {
      printf("    totalsize = %lld,\n", entry.file_totalsize);
      printf("    ioblocksize = %u,\n", entry.file_ioblocksize);
    }
    printf("  },\n");
    next_entry += entry.size;
  }
  printf("}\n");
  #assert(false); // unimplemented yet
  close(root_fd);
  return {};
}

func platform_next_paths(generator : PathListGenerator*)
{
  #assert(false); // uimplemented yet
}

func platform_free_generator(generator : PlatformPathListGenerator*)
{
  #assert(false); // unimplemented yet
}

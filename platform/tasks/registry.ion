import datum {...}
import containers {...}
import libc {
    libc_calloc = calloc,
    libc_free = free,
    libc_memset = memset,
    libc_realloc = realloc,
}

var unstarted_tasks : UnstartedTasks;

func registry_deinit()
{
  buf_free(unstarted_tasks.buf);
  unstarted_tasks = {};
}

struct TaskContent
{
  data : void*;
  fn : TaskFunc;
}

struct UnstartedTask
{
  id : Task;
  content : TaskContent;
  task_being_blocked : Task;
}

struct UnstartedTasks
{
  cap : usize;
  buf : UnstartedTask*;
}

func Task_compare(a : Task const, b : Task const) : int
{
  return a.value<b.value? -1 : (b.value<a.value? +1 : 0);
}

func unpack_generation_from_id(id : Task) : int
{
  return bits(id.value, 0, 4);
}

func unpack_idx_from_id(id : Task) : uint64
{
  return bits(id.value, 4, 60);
}

func pack_id(idx : usize, generation : int) : Task
{
  return { value = bits(idx, 0, 60)<<4 | bits(generation, 0, 4) };
}

func unstarted_create(self : UnstartedTasks*, content : TaskContent) : Task
{
  // allocate null task
  buf_alloc_at(&self.buf, sizeof(self.buf[0]), 0);

  n := buf_len(self.buf);
  idx := n;
  for (i:=1; i<n; i++) {
    if (!self.buf[i].content.fn) {
      idx = i;
      break;
    }
  }
  if (idx == n) {
    buf_alloc_at(&self.buf, sizeof(self.buf[0]), idx);
    self.cap = buf_len(self.buf);
  }
  #assert(idx < buf_len(self.buf));
  unstarted_task := &self.buf[idx];
  *unstarted_task = {
    id = pack_id(idx, unpack_generation_from_id(unstarted_task.id)+1),
    content = content,
  };
  return unstarted_task.id;
}

func check_valid_id(self : UnstartedTasks*, id : Task)
{
  idx := unpack_idx_from_id(id);
  #assert(idx < buf_len(self.buf));
  #assert(id.value == self.buf[idx].id.value);
}

func unstarted_discard(self : UnstartedTasks*, id : Task) : TaskContent
{
  check_valid_id(self, id);
  unstarted := &self.buf[unpack_idx_from_id(id)];
  content := unstarted.content;
  unstarted.content.fn = NULL; // mark as discarded
  return content;
}

func unstarted_depends_on(self : UnstartedTasks*, id : Task, predecessor_id : Task)
{
  check_valid_id(self, id);
  check_valid_id(self, predecessor_id);
  self.buf[unpack_idx_from_id(predecessor_id)].task_being_blocked = id;
}
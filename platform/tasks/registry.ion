import datum {...}
import containers {...}
import libc {
    libc_calloc = calloc,
    libc_free = free,
    libc_memset = memset,
    libc_realloc = realloc,
}

var unstarted_tasks : UnstartedTasks;
var threads : Threads;

func registry_init()
{
  threads_init(&threads, _get_num_logical_cpus());
}

func registry_deinit()
{
  threads_deinit(&threads);
  buf_free(unstarted_tasks.buf);
  unstarted_tasks = {};
}

struct TaskContent
{
  data : void*;
  fn : TaskFunc;
}

struct UnstartedTask
{
  id : Task;
  content : TaskContent;
  task_being_blocked : Task;
}

struct UnstartedTasks
{
  cap : usize;
  buf : UnstartedTask*;
}

struct TaskBlocker
{
  task : Task;
  blockers_exist_in_thread : uint64; // bitmap of threads with existing blocker task
}

struct PendingTasks
{
    len : usize;
    cap : usize;
    tasks : Task*;
    blocks : Task*; // task that is released when ours is done
    contents : TaskContent*;
}

struct ThreadWorkQueue
{
  blockers : TaskBlocker*;
  pending_tasks : PendingTasks;
}

struct Threads
{
  num_threads : usize;
  work_queues : ThreadWorkQueue*;
  // @todo: insert here per thread platform specific sync:
  // - mutex for mutual exclusion of reading/writing
  // - signal to signal when pending tasks are incoming, and wait when none exist
  // @todo: a thread work queue should not share same cache lines as any other 
}

func Task_compare(a : Task const, b : Task const) : int
{
  return a.value<b.value? -1 : (b.value<a.value? +1 : 0);
}

func unpack_generation_from_id(id : Task) : int
{
  return bits(id.value, 0, 4);
}

func unpack_idx_from_id(id : Task) : uint64
{
  return bits(id.value, 4, 60);
}

func pack_id(idx : usize, generation : int) : Task
{
  return { value = bits(idx, 0, 60)<<4 | bits(generation, 0, 4) };
}

func unstarted_create(self : UnstartedTasks*, content : TaskContent) : Task
{
  // allocate null task
  buf_alloc_at(&self.buf, sizeof(self.buf[0]), 0);

  n := buf_len(self.buf);
  idx := n;
  for (i:=1; i<n; i++) {
    if (!self.buf[i].content.fn) {
      idx = i;
      break;
    }
  }
  if (idx == n) {
    buf_alloc_at(&self.buf, sizeof(self.buf[0]), idx);
    self.cap = buf_len(self.buf);
  }
  #assert(idx < buf_len(self.buf));
  unstarted_task := &self.buf[idx];
  *unstarted_task = {
    id = pack_id(idx, unpack_generation_from_id(unstarted_task.id)+1),
    content = content,
  };
  return unstarted_task.id;
}

func check_valid_id(self : UnstartedTasks*, id : Task)
{
  idx := unpack_idx_from_id(id);
  #assert(idx < buf_len(self.buf));
  #assert(id.value == self.buf[idx].id.value);
}

func unstarted_discard(self : UnstartedTasks*, id : Task) : TaskContent
{
  check_valid_id(self, id);
  unstarted := &self.buf[unpack_idx_from_id(id)];
  content := unstarted.content;
  unstarted.content.fn = NULL; // mark as discarded
  return content;
}

func unstarted_depends_on(self : UnstartedTasks*, id : Task, predecessor_id : Task)
{
  check_valid_id(self, id);
  check_valid_id(self, predecessor_id);
  self.buf[unpack_idx_from_id(predecessor_id)].task_being_blocked = id;
}

func threads_init(self : Threads*, num_threads : usize)
{
  #assert(num_threads < 64);
  self.num_threads = num_threads;
  self.work_queues = libc_calloc(self.num_threads, sizeof(self.work_queues[0]));
}

func threads_deinit(self : Threads*)
{
  libc_free(self.work_queues);
  *self = {};
}

func threads_alloc_for_num_tasks(self : Threads*, num_tasks : usize)
{
  #assert(false); // not yet implemented
}

func threads_enqueue_task(self : Threads*, task : Task, blocked_task : Task, content : TaskContent)
{
  #assert(false); // not yet implemented
}

func pending_tasks_add(dest : PendingTasks*, task : Task, blocked_task : Task, content : TaskContent)
{
  *(:Task*)buf_alloc_at(&dest.tasks, sizeof(dest.tasks[0]), dest.len) = task;
  *(:Task*)buf_alloc_at(&dest.blocks, sizeof(dest.blocks[0]), dest.len) = blocked_task;
  *(:TaskContent*)buf_alloc_at(&dest.contents, sizeof(dest.contents[0]), dest.len) = content;
  dest.len++;
  #assert(dest.len == buf_len(dest.tasks));
  #assert(dest.len == buf_len(dest.blocks));
  #assert(dest.len == buf_len(dest.contents));
  dest.cap = dest.len;
}

// @todo binary search in blockers
// @todo clean-up old blockers (partition and put at the end)

func blockers_put(blockers_ptr : TaskBlocker**, task : Task, has_blockers_bitmask : uint64)
{
  blockers : TaskBlocker const* const = *blockers_ptr;
  idx := buf_len(blockers);
  for (i:=0; i<buf_len(blockers); i++) {
    cmp := Task_compare(blockers[i].task, task);
    if (cmp < 0) { continue; }
    if (cmp == 0) {
      idx = i;
    }
    break;
  }
  blocker : TaskBlocker* = buf_alloc_at(blockers_ptr, sizeof(blockers[0]), idx);
  blocker.task = task;
  blocker.blockers_exist_in_thread |= has_blockers_bitmask;
}

func blockers_map(dest : ThreadWorkQueue*, has_blockers_bitmask : uint64, num_tasks : usize, tasks : Task*, blocked_tasks : Task*)
{
  // reset all
  for (i:=0; i<buf_len(dest.blockers); i++) {
    dest.blockers[i].blockers_exist_in_thread &= ~has_blockers_bitmask;
  }
  for (i:=0; i<dest.pending_tasks.len; i++) {
    task := dest.pending_tasks.tasks[i];
    is_blocked_by_task : bool;
    for (j:=0; j<num_tasks; j++) {
      if (Task_compare(blocked_tasks[j], task) != 0) { continue; }
      is_blocked_by_task = true;
      break;
    }
    if (!is_blocked_by_task) { continue; }
    blockers_put(&dest.blockers, task, has_blockers_bitmask);
  }
}

func thread_work_queue_find_index_first_ready(self : ThreadWorkQueue const*) : int
{
  for (i:= 0; i <self.pending_tasks.len; i++) {
    task := self.pending_tasks.tasks[i];
    ready := true;
    for (j:= 0; j<buf_len(self.blockers); j++) {
      if (Task_compare(self.blockers[j].task, task) != 0) { continue; }
      if (self.blockers[j].blockers_exist_in_thread) {
        ready = false;
      }
      break;
    }
    if (!ready) { continue; }
    return i;
  }
  return self.pending_tasks.len;
}

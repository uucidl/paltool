import .dispatch {...}
import libc { calloc, puts, realloc, memset, free }
import datum {...}
import platform.bsd {bsd_size}

var submission_queue : Queue;
var main_queue : Queue;

func platform_tasks_init() {
  submission_queue = queue_create("tasks_submit", NULL);
  #assert(submission_queue);
  main_queue = queue_create("tasks_main", NULL);
  set_target_queue({_dq=main_queue}, get_global_queue(QUEUE_PRIORITY_DEFAULT, 0));
}

func platform_tasks_deinit() {
  #assert(submission_queue);
  release({_dq=submission_queue});
  release({_dq=main_queue});
  submission_queue = NULL;
  registry_deinit();
}

struct NewTaskData
{
  data : void*;
  fn : TaskFunc;
  task : Task;
}


func _add_task_submission_task(opaque_data : void*) {
  data : NewTaskData* = opaque_data;
  data.task = unstarted_create(&unstarted_tasks, {data=data.data, fn=data.fn});
}

// Create a new task and returns its handle
func platform_create_task(fn : TaskFunc, data : void*) : Task {
  #assert(submission_queue); // you forgot to call tasks_init
  submission_data := NewTaskData {
    data = data,
    fn = fn,
  };
  sync(submission_queue, &submission_data, _add_task_submission_task);
  return submission_data.task;
}

// Mark a dependency between two tasks
func platform_task_depends_on(task : Task, dependency : Task) {
  unstarted_depends_on(&unstarted_tasks, task, dependency);
}

func run_task_task(opaque_data : void*) {
  data : TaskContent* = opaque_data;
  data.fn(data.data);
  data.fn = NULL; // mark task has completed.
  free(data);
}

// Schedule a task to run as soon as possible
func platform_start_task(task : Task) {
  // @todo: thread safety with submission
  content := unstarted_discard(&unstarted_tasks, task);
  content_ptr := &content;
  content_ptr = calloc(1, sizeof(content_ptr[0]));
  *content_ptr = content;
  async(main_queue, content_ptr, run_task_task);
}

func puts_task(data : void*) {
  puts((:char*)data);
}

func _get_num_logical_cpus() : int
{
  count : int;
  count_size := (:bsd_size) sizeof(count);
  rc := bsd.sysctlbyname("hw.activecpu", &count, &count_size, NULL, 0);
  if (rc == 0) { return count; }
  rc = bsd.sysctlbyname("hw.logicalcpu", &count, &count_size, NULL, 0);
  if (rc == 0) { return count; }
  rc = bsd.sysctlbyname("hw.ncpu", &count, &count_size, NULL, 0);
  if (rc == 0) { return count; }
  return 0;
}
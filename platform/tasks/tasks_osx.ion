import .dispatch {...}
import libc { calloc, puts, realloc, memset, free }
import datum {...}
import platform.bsd {bsd_size}

var submission_queue : Queue;
var main_queue : Queue;

func platform_tasks_init() {
  submission_queue = queue_create("tasks_submit", NULL);
  #assert(submission_queue);
  main_queue = queue_create("tasks_main", NULL);
  set_target_queue({_dq=main_queue}, get_global_queue(QUEUE_PRIORITY_DEFAULT, 0));
}

func platform_tasks_deinit() {
  #assert(submission_queue);
  release({_dq=submission_queue});
  release({_dq=main_queue});
  submission_queue = NULL;
  registry_deinit();
}

struct NewTaskData
{
  data : void*;
  fn : TaskFunc;
  task : Task;
}


func _add_task_submission_task(opaque_data : void*) {
  data : NewTaskData* = opaque_data;
  id := unstarted_create(&registry.unstarted, {data=data.data, fn=data.fn});
  legacy := registry_add(data.data, data.fn);
  data.task = Task{
    new_id = id.value,
    id = legacy.id,
  };
}

// Create a new task and returns its handle
func platform_create_task(fn : TaskFunc, data : void*) : Task {
  #assert(submission_queue); // you forgot to call tasks_init
  submission_data := NewTaskData {
    data = data,
    fn = fn,
  };
  sync(submission_queue, &submission_data, _add_task_submission_task);
  return submission_data.task;
}

// Mark a dependency between two tasks
func platform_task_depends_on(task : Task, dependency : Task) {
  unstarted_depends_on(&registry.unstarted, {task.new_id}, {dependency.new_id});
}

func run_task_task(opaque_data : void*) {
  data : TaskContent* = opaque_data;
  data.fn(data.data);
  data.fn = NULL; // mark task has completed.
}

// Schedule a task to run as soon as possible
func platform_start_task(task : Task) {
  // @todo: thread safety with submission
  // @todo: get content from unstarted task, and remove legacy registry
  // content := unstarted_get(&registry.unstarted, {task.new_id});
  unstarted_discard(&registry.unstarted, {task.new_id});
  
  content_ptr := registry_get(task);
  content_ptr.started = true;
  async(main_queue, content_ptr, run_task_task);
}

func puts_task(data : void*) {
  puts((:char*)data);
}

// @todo introduce a c_size to represent size_t in bsd/posix etc apis
// since usize isn't necessarily compatible without compiler warnings
func _get_num_logical_cpus() : int
{
  count : int;
  count_size := (:bsd_size) sizeof(count);
  rc := bsd.sysctlbyname("hw.logicalcpu", &count, &count_size, NULL, 0);
  if (rc == 0) { return count; }
  rc = bsd.sysctlbyname("hw.ncpu", &count, &count_size, NULL, 0);
  if (rc == 0) { return count; }
  return 0;
}
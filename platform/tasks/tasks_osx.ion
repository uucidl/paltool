import .dispatch {...}
import libc { calloc, puts, realloc, memset, free }
import datum {...}

var submission_queue : Queue;
var main_queue : Queue;

func platform_tasks_init() {
  submission_queue = queue_create("tasks_submit", NULL);
  #assert(submission_queue);
  main_queue = queue_create("tasks_main", NULL);
  set_target_queue({_dq=main_queue}, get_global_queue(QUEUE_PRIORITY_DEFAULT, 0));
}

func platform_tasks_deinit() {
  #assert(submission_queue);
  release({_dq=submission_queue});
  release({_dq=main_queue});
  submission_queue = NULL;
  registry_deinit();
}

struct NewTaskData
{
  data : void*;
  fn : TaskFunc;
  task : Task;
}


func _add_task_submission_task(opaque_data : void*) {
  data : NewTaskData* = opaque_data;
  data.task = registry_add(data.data, data.fn);
}

// Create a new task and returns its handle
func platform_create_task(fn : TaskFunc, data : void*) : Task {
  #assert(submission_queue); // you forgot to call tasks_init
  submission_data := NewTaskData {
    data = data,
    fn = fn,
  };
  sync(submission_queue, &submission_data, _add_task_submission_task);
  return submission_data.task;
}

// Mark a dependency between two tasks
func platform_task_depends_on(task : Task, dependency : Task) {
  #assert(false);
}

func run_task_task(opaque_data : void*) {
  data : TaskContent* = opaque_data;
  data.fn(data.data);
  data.fn = NULL; // mark task has completed.
}

// Schedule a task to run as soon as possible
func platform_start_task(task : Task) {
  // @todo: thread safety with submission
  content := registry_get(task);
  content.started = true;
  async(main_queue, content, run_task_task);
}

func puts_task(data : void*) {
  puts((:char*)data);
}


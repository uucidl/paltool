import platform.win32 { 
  SYSTEM_INFO = SYSTEM_INFO,
  GetSystemInfo = GetSystemInfo,
}

/*

Context
- user wants to maximize CPU core utilization,
- user has many independent chunks of computations,
- tasks are >=1ms worth of CPU processing,
- tasks don't do general I/O, only CPU + Mem

Value
- duration(task_processing(tasks, core_count)) < duration(serial_processing(tasks))
  when core_count > 1
- core_count_1 > core_count_0 => duration(task_processing(tasks, core_count_1)) 
  < duration(task_processing(tasks, core_count_0))

Cost  
- overhead = duration(task_processing(tasks, core_count)) - duration(serial_procesing(tasks))/core_count

Plan
- create one worker thread per core
  + @todo: obtain number of physical cores
  + @todo: worker thread main loop + win32 creation code
- transport tasks to worker threads
  + 1 task processed for every task started
  + what's acceptable latency? best-effort? Next available core should pick-up the work.

*/

func platform_tasks_init()
{
}

func platform_tasks_deinit()
{
}

func platform_create_task(fn : TaskFunc, data : void*) : Task
{
	return {};
}


func platform_task_depends_on(task : Task, dependency : Task)
{
}

// Schedule a task to run as soon as possible
func platform_start_task(task : Task)
{
    #assert(false); // unimplemented
}

func _get_num_logical_cpus() : int
{
  system_info : SYSTEM_INFO;
  GetSystemInfo(&system_info);
  return system_info.dwNumberOfProcessors;
}
import platform.bsd
import libc
import containers { ... }

struct PlatformPathListGenerator
{
  fd : int;
  batch_mem : uint32[16*1024];
}

struct QueryResult
{
  size       : uint32;
  attributes : bsd.AttributeSet;
  error : uint32;
  nameinfo : bsd.Attrreference;
  objtype : bsd.FSObjType;
  objtag : bsd.FSObjTag;
  union {
    struct {
      file_totalsize : bsd.Off;
      file_ioblocksize : uint32;
    }
  }
  name       : char*;        // derived
}

func unpack_query_result(bytes : uint8 const*, num_bytes : usize) : QueryResult {
  nameinfo := *((:bsd.Attrreference*)&bytes[28]);
  return {
    size = *((:uint32*)&bytes[0]),
    attributes = *((:bsd.AttributeSet*)&bytes[4]),
    error = *((:uint32*)&bytes[24]),
    nameinfo = *((:bsd.Attrreference*)&bytes[28]),
    objtype = *((:bsd.FSObjType*)&bytes[36]),
    objtag = *((:bsd.FSObjType*)&bytes[40]),
    file_totalsize = *((:bsd.Off*)&bytes[44]),
    file_ioblocksize = *((:uint32*)&bytes[52]),
    name = (:char*)&bytes[28 + nameinfo.attr_dataoffset],
  };
}
  
func make_attrlist_for_QueryResult() : bsd.AttrList
{
  return bsd.make_attrlist({
      commonattr = bsd.ATTR_CMN_RETURNED_ATTRS | bsd.ATTR_CMN_ERROR | bsd.ATTR_CMN_NAME | bsd.ATTR_CMN_OBJTYPE | bsd.ATTR_CMN_OBJTAG,
      fileattr = bsd.ATTR_FILE_TOTALSIZE | bsd.ATTR_FILE_IOBLOCKSIZE,
  });
}

func make_macos_path_list_generator(root_fd : int) : PlatformPathListGenerator
{
  return {
    fd = root_fd,
  };
}

func platform_find_all_files(root : uint8 const*) : PathListGenerator
{
  root_path := (:char const*)root;
  fd_or_error := bsd.open(root_path, bsd.O_RDONLY, 0);
  if (fd_or_error < 0) {
    return { error = PathListError_InvalidRoot };
  }
  #assert(fd_or_error >= 0);
  root_fd := fd_or_error;
  resources : PlatformPathListGenerator* = libc.calloc(1, sizeof(PlatformPathListGenerator));
  *resources = make_macos_path_list_generator(root_fd);
  return {
    resources = resources,
  };
}

func platform_next_paths(generator : PathListGenerator*)
{
  #assert(generator.error == PathListError_None);
  root_fd := generator.resources.fd;
  query := make_attrlist_for_QueryResult();
  options := uint64(bsd.FSOPT_NOFOLLOW | bsd.FSOPT_REPORT_FULLSIZE | bsd.FSOPT_PACK_INVAL_ATTRS);
  num_entries_or_error := bsd.getattrlistbulk(root_fd, &query, &generator.resources.batch_mem[0], sizeof(generator.resources.batch_mem), options);
  if (num_entries_or_error < 0) {
    #assert(bsd.errno != bsd.EFAULT);
    #assert(bsd.errno != bsd.ERANGE);
    #assert(bsd.errno != bsd.EINVAL);
    generator.error = (bsd.errno == bsd.EBADF || bsd.errno == bsd.ENOTDIR)
      ? PathListError_InvalidRoot
      : PathListError_FileSystemError;
    return;
  }

  #assert(num_entries_or_error >= 0);
  num_entries := num_entries_or_error;
  if (num_entries == 0) {
    generator.error = PathListError_PastTheEnd;
    return;
  }

  if (generator.output.filepaths) {
    buf_hdr_mutable(generator.output.filepaths).size = 0;
    generator.output.num_filepaths = 0;
  }
  if (generator.output.dirpaths) {
    buf_hdr_mutable(generator.output.dirpaths).size = 0;
    generator.output.num_dirpaths = 0;
  }
  
  batch_offset := 0;
  next_entry := (:uint8*)&generator.resources.batch_mem[0];
  for (entries_idx := 0; entries_idx < num_entries; entries_idx++) {
  remaining_num_bytes := (:uint8*)&generator.resources.batch_mem[sizeof(generator.resources.batch_mem)/sizeof(generator.resources.batch_mem[0])] - next_entry;
    entry := unpack_query_result(next_entry, remaining_num_bytes);
    if (entry.objtype == bsd.VREG) {
       buf_push(&generator.output.filepaths, &entry.name, sizeof(entry.name));
    } else {
       buf_push(&generator.output.dirpaths, &entry.name, sizeof(entry.name));
    }
    next_entry += entry.size;
  }
  generator.output.num_filepaths = buf_len(generator.output.filepaths);
  generator.output.num_dirpaths = buf_len(generator.output.dirpaths);
}

func platform_free_generator(generator : PathListGenerator*)
{
  buf_free(generator.output.filepaths);
  buf_free(generator.output.dirpaths);
  if (generator.resources)
  {
    bsd.close(generator.resources.fd);
    libc.free(generator.resources);
    generator.resources = NULL;
  }
}


